import { Button, Tooltip, message, Tag } from "antd";
import {
  CaretUpOutlined,
  CaretDownOutlined,
  CopyOutlined,
} from "@ant-design/icons";
import { BALANCEARRAYS } from "../constants";
import TransactionService from "../services/transaction.service";
import SettingService from "../services/setting.service";
import UserService from "../services/user.service";
import copy from "copy-to-clipboard";
export function dateProcessor(date) {
  return (
    new Date(date).getFullYear() +
    "-" +
    (new Date(date).getMonth() + 1) +
    "-" +
    new Date(date).getDate() +
    " " +
    new Date(date).getHours() +
    ":" +
    new Date(date).getMinutes()
  );
}

export function usernameProcessor(name) {
  return name[0].toUpperCase() + name.slice(1);
}

export function stopProcessor(mode, timeLine, id) {
  const nowTime = new Date().getTime();
  const expiredTime = new Date(timeLine).getTime();
  let titleButton = "";
  if (expiredTime >= nowTime) titleButton = "STOP";
  else titleButton = "DONE";
  return (
    <Button
      type="primary"
      onClick={() => stopTransaction(id)}
      disabled={mode === 0 || titleButton === "DONE" ? true : false}
    >
      {titleButton}
    </Button>
  );
}
async function stopTransaction(id) {
  let data = { status: false, expiredTime: new Date() };
  await TransactionService.stopTransaction({ id }).then((response) => {
    data = response.data.data;
  });
  return data;
}
export function priceChangeProcessor(change) {
  return change >= 0 ? (
    <h6 style={{ color: "green" }}>
      {Math.fround(change).toFixed(2)}
      <CaretUpOutlined twoToneColor="green" />
    </h6>
  ) : (
    <h6 style={{ color: "red" }}>
      {Math.fround(change).toFixed(2)}
      <CaretDownOutlined twoToneColor="red" />
    </h6>
  );
}
export function priceProcessor(price, change) {
  return change >= 0 ? (
    <h6 style={{ color: "green" }}>{Math.fround(price).toFixed(2)}</h6>
  ) : (
    <h6 style={{ color: "red" }}>{Math.fround(price).toFixed(2)}</h6>
  );
}

function statusProcessor(status) {
  return status === "success" ? (
    <Tag style={{ color: "green" }}>{status}</Tag>
  ) : status === "pending" || status === "confirm" ? (
    <Tag style={{ color: "yellow" }}>{status}</Tag>
  ) : (
    <Tag style={{ color: "red" }}>{status}</Tag>
  );
}

export function txhashProcessor(txhash, currency) {
  return currency === BALANCEARRAYS[0].currency ? (
    txhash ? (
      <a
        href={"https://etherscan.io/tx/" + txhash}
        target="_blank"
        rel="noopener noreferrer"
      >
        <Tooltip placement="top" title={txhash}>
          <b style={{ color: "DodgerBlue" }}>
            {txhash.slice(0, 3)}..
            {txhash.slice(txhash.length - 2, txhash.length)}
          </b>
        </Tooltip>
      </a>
    ) : (
      "-----"
    )
  ) : currency === BALANCEARRAYS[2].currency ? (
    txhash ? (
      <a
        href={"https://tronscan.io/#/transaction/" + txhash}
        target="_blank"
        rel="noopener noreferrer"
      >
        <Tooltip placement="top" title={txhash}>
          <b style={{ color: "DodgerBlue" }}>
            {txhash.slice(0, 3)}..
            {txhash.slice(txhash.length - 2, txhash.length)}
          </b>
        </Tooltip>
      </a>
    ) : (
      "-----"
    )
  ) : (
    "-"
  );
}

function addressProcessor(address, currency) {
  return currency === BALANCEARRAYS[0].currency ? (
    address ? (
      <>
        <a
          href={"https://etherscan.io/address/" + address}
          target="_blank"
          rel="noopener noreferrer"
        >
          <Tooltip placement="top" title={address}>
            <b style={{ color: "DodgerBlue" }}>
              {address.slice(0, 3)}..
              {address.slice(address.length - 2, address.length)} {"  "}
            </b>
          </Tooltip>
        </a>
        <Button
          type="text"
          onClick={() => {
            copy(address);
            message.success("Copyed!");
          }}
        >
          <CopyOutlined />
        </Button>
      </>
    ) : (
      "-----"
    )
  ) : currency === BALANCEARRAYS[2].currency ? (
    address ? (
      <>
        <a
          href={"https://tronscan.io/#/address/" + address}
          target="_blank"
          rel="noopener noreferrer"
        >
          <Tooltip placement="top" title={address}>
            <b style={{ color: "DodgerBlue" }}>
              {address.slice(0, 3)}..
              {address.slice(address.length - 2, address.length)} {"  "}
            </b>
          </Tooltip>
        </a>
        <Button
          type="text"
          onClick={() => {
            copy(address);
            message.success("Copyed!");
          }}
        >
          <CopyOutlined />
        </Button>
      </>
    ) : (
      "-----"
    )
  ) : (
    "-"
  );
}

function fakeIdProcessor(shortID) {
  return shortID ? (
    <Tooltip placement="top" title={shortID}>
      <b style={{ color: "DodgerBlue" }}>
        {shortID.slice(0, 3)}..
        {shortID.slice(shortID.length - 2, shortID.length)} {"  "}
      </b>
    </Tooltip>
  ) : (
    "-----"
  );
}
export function calculateRealAvailableBalance(reflectBalanceState) {
  let data = [];
  reflectBalanceState.reflectuserBalances.map((currency, index) => {
    const balance =
      reflectBalanceState.reflectuserBalances[index].availableBalance +
      reflectBalanceState.reflectuserDeposits[index].profitAmount -
      reflectBalanceState.reflectuserDeposits[index].depositBalance -
      reflectBalanceState.reflectuserWithdraws[index].totalWithdrawed -
      reflectBalanceState.reflectuserWithdraws[index].pendingWithdraw;
    data.push(balance);
  });
  return data;
}
export function refactorBalances(balances) {
  let reflectuserBalances = [];
  let reflectuserWithdraws = [];
  let reflectuserDeposits = [];

  BALANCEARRAYS.map((array) => {
    let balanceTemp;
    balances.userTotalBalances.map((utb, index) => {
      if (array.currency === utb.currency) balanceTemp = utb;
    });
    if (balanceTemp)
      reflectuserBalances.push({
        availableBalance: balanceTemp.availableBalance
          ? balanceTemp.availableBalance
          : 0,
        pendingBalance: balanceTemp.pendingBalance
          ? balanceTemp.pendingBalance
          : 0,
      });
    else
      reflectuserBalances.push({
        currency: array.currency,
        availableBalance: 0,
        pendingBalance: 0,
      });
    let withdrawTemp;
    balances.userTotalWithdraws.map((utw, index) => {
      if (array.currency === utw.currency) withdrawTemp = utw;
    });
    if (withdrawTemp)
      reflectuserWithdraws.push({
        pendingWithdraw: withdrawTemp.pendingWithdraw
          ? withdrawTemp.pendingWithdraw
          : 0,
        totalWithdrawed: withdrawTemp.totalWithdrawed
          ? withdrawTemp.totalWithdrawed
          : 0,
      });
    else
      reflectuserWithdraws.push({
        currency: array.currency,
        totalWithdrawed: 0,
        pendingWithdraw: 0,
      });

    let depositTemp;
    balances.userDepositBalances.map((udb, index) => {
      if (array.currency === udb.currency) depositTemp = udb;
    });
    if (depositTemp)
      reflectuserDeposits.push({
        depositBalance: depositTemp.depositBalance
          ? depositTemp.depositBalance
          : 0,
        profitAmount: depositTemp.profitAmount ? depositTemp.profitAmount : 0,
        totalDepositAmount: depositTemp.totalDepositAmount
          ? depositTemp.totalDepositAmount
          : 0,
      });
    else
      reflectuserDeposits.push({
        currency: array.currency,
        depositBalance: 0,
        totalDepositAmount: 0,
        profitAmount: 0,
      });
  });
  return { reflectuserBalances, reflectuserWithdraws, reflectuserDeposits };
}
export async function getCompanyAccount() {
  let id = 1;
  await UserService.getCompanyAccount().then((response) => {
    id = response.data.data.id;
  });
  return id;
}
export async function getCompanyBalance() {
  let balance = 1;
  await TransactionService.getCompanyAccount().then((response) => {
    balance = response.data.data;
  });
  return balance;
}
export async function processingfetchingDeposit(
  user_id,
  page = 1,
  pageSize = 10,
  order = "DESC"
) {
  let data = [];
  await TransactionService.fetchDeposits({
    user_id,
    page,
    pageSize,
    order,
  }).then((response) => {
    response.data.data.models.map((model) => {
      model.key = model.id;
      model.profit = Math.fround(model.profit).toFixed(2);
      model.action = stopProcessor(model.mode, model.expiretime, model.id);
      model.mode = model.mode ? (
        <Tag style={{ color: "yellow" }}>Auto</Tag>
      ) : (
        <Tag style={{ color: "green" }}>Manual</Tag>
      );
      model.created_at = dateProcessor(model.created_at);
      model.expiretime = dateProcessor(model.expiretime);
      model.txhash = fakeIdProcessor(model.txhash);
      model.amount = Math.fround(model.amount).toFixed(2);
      model.earned =
        model.status === "pending" ? "-" : Math.fround(model.earned).toFixed(3);
      model.u_earned =
        model.status === "pending"
          ? "-"
          : Math.fround(model.u_earned).toFixed(3);
      model.c_earned =
        model.status === "pending"
          ? "-"
          : Math.fround(model.c_earned).toFixed(3);
      model.status = statusProcessor(model.status);

      data.push({ ...model });
    });
  });
  return data;
}

export async function processingfetchingWithdraw(user_id) {
  let data = [];
  await TransactionService.fetchWithdraws(user_id).then((response) => {
    let filteredwithdraws;
    if (!user_id)
      filteredwithdraws = response.data.data.models.filter(
        (model) => model.status === "success"
      );
    else filteredwithdraws = response.data.data.models;
    filteredwithdraws.map((model) => {
      model.receiver = addressProcessor(model.receiver, model.currency);
      model.txhash = txhashProcessor(model.txhash, model.currency);
      model.created_at = dateProcessor(model.created_at);
      model.amount = Math.fround(model.amount).toFixed(2);
      model.status = statusProcessor(model.status);
      data.push({ ...model });
    });
  });
  return data;
}

export async function processingfetchingPlatformStatistics() {
  let data = {
    registeredby24: 0,
    allusers: 0,
    tradevolume: 0,
    roi: 0,
    openorders: 0,
    closedorders: 0,
    created_at: "",
  };
  await TransactionService.fetchStatistics().then((response) => {
    data = response.data.data;
  });
  return data;
}
export async function processingfetchingBalances(user_id) {
  let data = {};
  await TransactionService.fetchBalances(user_id).then((response) => {
    data = response.data.data;
  });
  return data;
}

export async function processingfetchingTokenPrices(user_id) {
  let data = {};
  await TransactionService.fetchUsdtEthPrices().then((response) => {
    data = response.data.data;
  });
  return data;
}

export async function processingfetchingTxsHistory() {
  let returnData = [];
  await TransactionService.fetchTransactionList().then((response) => {
    response.data.data.models.map((model, index) => {
      model.no = index + 1;
      model.created_at = dateProcessor(model.created_at);
      model.txhash = txhashProcessor(model.txhash, model.currency);
      model.amount = Math.fround(model.amount).toFixed(2);
      returnData.push({ ...model });
    });
  });
  return returnData;
}

export async function requestWithdraw(
  user_id,
  amount,
  receiver,
  optionState,
  token2fa,
  isCompany = false
) {
  let result = {};
  await TransactionService.postWithdraw({
    user_id,
    amount,
    receiver,
    currency: BALANCEARRAYS[optionState.currencyId].currency,
    token2fa,
    isCompany,
  }).then(
    (response) => {
      const res = response.data.data;
      if (res)
        result = {
          status: "success",
          title: "Successfully Withdrawed Server in Tether Trader",
          subTitle: `Transaction Hash : ${res}`,
        };
      else
        result = {
          status: "error",
          title: "There are some problems with server operation.",
          subTitle: "Contact Administrator",
        };
    },
    (error) => {
      result = {
        status: "error",
        title: "There are some problems with server operation.",
        subTitle: error.response.data.error.message,
      };
    }
  );
  return result;
}

export async function processingfetchingAddFunds(user_id) {
  let data = [];
  await TransactionService.fetchAddFundsList(user_id).then((response) => {
    response.data.data.map((model) => {
      model.hash = txhashProcessor(model.hash, model.currency);
      model.created_at = dateProcessor(model.created_at);
      model.amount = Math.fround(model.amount).toFixed(2);
      model.status = statusProcessor(model.status);
      model.address = addressProcessor(model.address, model.currency);
      data.push({ ...model });
    });
  });
  return data;
}

export async function requestAddFund(user_id, amount, currency) {
  let result = {};
  await TransactionService.testAddFund({
    user_id,
    amount,
    currency,
  }).then(
    (response) => {
      const address = response.data.data;
      if (address)
        result = {
          status: "success",
          title: "Successfully Registered in Tether Trader",
          address,
          url: `https://etherscan.io/address/${address}`,
          subTitle: (
            <>
              <p>
                Your Deposit Address : {address}
                <Button
                  type="text"
                  onClick={() => {
                    copy(address);
                    message.success("Copyed!");
                  }}
                >
                  <CopyOutlined />
                </Button>{" "}
              </p>
              <p>
                After purchasing your money and the system start the service
                right.
              </p>
            </>
          ),
        };
      else
        result = {
          status: "error",
          title: "There are some problems with server operation.",
          subTitle: "Contact Administrator",
        };
    },
    (error) => {
      result = {
        status: "error",
        title: "There are some problems with the system.",
        subTitle: `Server Error : ${error.response.data.error.message} `,
      };
    }
  );
  return result;
}

export async function requestDeposit(user_id, amount, currency, time, profit, mode=0) {
  let result = {};
  await TransactionService.postDeposit({
    user_id,
    amount,
    currency,
    time,
    profit,
    mode
  }).then(
    (response) => {
      const id = response.data.data;
      result = {
        status: "success",
        title: "Successfully Delivered to Server ! ",
        subTitle: `Transaction Id is ${id}`,
      };
    },

    (error) => {
      result = {
        status: "error",
        title: "There are some problems with the system.",
        subTitle: `Server Error : ${error.response.data.error.message} `,
      };
    }
  );
  return result;
}

export async function processingfetchingAllUsers(user) {
  let rowCount = 10;
  let users = [];
  await UserService.fetchAllUserList(user).then((response) => {
    response.data.data.models.map((model, index) => {
      model.no = index + 1;
      model.created_at = dateProcessor(model.created_at);
      model.username = usernameProcessor(model.username);
      users.push({ ...model });
    });
    rowCount = response.data.data.pagination.rowCount;
  });
  return { users, rowCount };
}

export async function processingfetchingServerWallet(user_id) {
  let data = {};
  await UserService.fetchServerWalletInfo().then((response) => {
    data = response.data.data;
  });
  return data;
}

export async function requestQRcode(user_id) {
  let result = { qr: "" };
  await TransactionService.getQRcode(user_id).then((response) => {
    result = response.data.data;
  });
  return result;
}

export async function isAutoMode() {
  let result = { timeline: new Date(), timenow: new Date(), status: false };
  await UserService.isAutoMode().then((response) => {
    result = response.data.data;
  });
  return result;
}

export async function makeAutoMode(user) {
  let result = { timeline: new Date(), timenow: new Date(), status: false };
  await UserService.makeAutoMode(user).then((response) => {
    result = response.data.data;
  });
  return result;
}

export async function requestUpdateUser(user) {
  let result = {};
  await UserService.updateUserData(user).then(
    () => {
      result = {
        status: "success",
        title: "Successfully Updated User Profile",
        subTitle: `Your password was changed successfully.`,
      };
    },
    (error) => {
      result = {
        status: "error",
        title: "There are some problems with the system.",
        subTitle: `Server Error : ${error.response.data.error.message} `,
      };
    }
  );
  return result;
}

export async function processingfetchingMarketPrices() {
  let data = [];
  await TransactionService.fetchMarketPrices().then((response) => {
    response.data.data.map((model, index) => {
      model.no = index + 1;
      model.volume = volumeProcessor(model.volume);
      model.buy = priceProcessor(model.buy, model.change);
      model.sell = priceProcessor(model.sell, model.change);
      model.change = priceChangeProcessor(model.change);
      data.push(model);
    });
  });
  return data;
}

export function reflectPrices(prices, count) {
  if (!prices.length)
    for (let i = 0; i < count; i++)
      prices.push({ buy: 0, sell: 0, volume: 0, change: 0 });

  return prices;
}

export function volumeProcessor(volume) {
  const refactorVolume = Math.round(volume);
  const rest = refactorVolume.toString().length % 3;
  const times = Math.trunc(refactorVolume.toString().length / 3);
  const unitByTimes = ["", "", "K", "M", "G", "T"];

  if (!times) {
    return refactorVolume;
  } else {
    const returnData = rest
      ? refactorVolume.toString().slice(0, rest) +
        "," +
        refactorVolume.toString().slice(rest, rest + 2) +
        unitByTimes[times]
      : 0 +
        "." +
        refactorVolume.toString().slice(0, 2) +
        unitByTimes[times - 1];
    return returnData;
  }
}

export async function walletInfoFromPk(reqData) {
  let data = "";
  await SettingService.walletInfoFromPk(reqData).then((response) => {
    data = response.data.data;
  });
  return data;
}

export async function processingfetchingFlashloan() {
  let data = [];
  await TransactionService.fetchFlashLoanPrices().then((response) => {
    const model = response.data.data;
    const usdtTemp = {
      key: 1,
      token: "USDT",
      v2amountin: Math.fround(model[0].uniswap[0].usdt.inA).toFixed(2),
      v2amountout: Math.fround(model[0].uniswap[0].usdt.outA).toFixed(2),
      sushiamountin: Math.fround(model[1].sushiswap[0].usdt.inA).toFixed(2),
      sushiamountout: Math.fround(model[1].sushiswap[0].usdt.outA).toFixed(2),
    };
    data.push(usdtTemp);
    const daiTemp = {
      key: 2,
      token: "DAI",
      v2amountin: Math.fround(model[0].uniswap[1].dai.inA).toFixed(4),
      v2amountout: Math.fround(model[0].uniswap[1].dai.outA).toFixed(4),
      sushiamountin: Math.fround(model[1].sushiswap[1].dai.inA).toFixed(4),
      sushiamountout: Math.fround(model[1].sushiswap[1].dai.outA).toFixed(4),
    };
    data.push(daiTemp);
  });
  return data;
}

export async function runFlashLoanBot(reqData) {
  let data = "";
  await TransactionService.runFlashLoanBot(reqData).then((response) => {
    data = response.data.data;
  });
  return data;
}
